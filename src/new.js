const fs = require('fs-extra')
const path = require('path')
const chalk = require('chalk').default
const spawn = require('cross-spawn')
const ora = require('ora')
const os = require('os')
const validateProjectName = require('validate-npm-package-name')

const exitWithError = require('./helpers/exitWithError')

const repositoryUrl = 'https://github.com/kayKayEhnn/typescript-react-redux-boilerplate.git'

// These files should be allowed to remain on a failed install,
// but then silently removed during the next create.
const errorLogFilePatterns = ['npm-debug.log', 'yarn-error.log', 'yarn-debug.log']

module.exports = async function newProject(appNameArg, options) {
  try {
    const appPath = path.resolve(appNameArg)
    const appName = path.basename(appPath)

    checkAppName(appName)

    fs.ensureDirSync(appPath)
    isSafeToCreateProjectIn(appPath, appName)

    let spinner = ora('Cloning boilerplate...').start()

    let child = spawn('git', ['clone', repositoryUrl, appPath, '--depth=1'])
    await promisifySpawn(child, 'git clone')

    spinner.succeed('Cloned boilerplate')

    await modifyDefaults(appName, appPath)

    console.log('Installing packages. This may take a few minutes.')
    installPackages(appPath)

    if (options.commit) {
      createInitialCommit(appPath)
    }

    console.log()
    console.log(`Success! Created ${appName} at ${appPath}`)
    console.log('Inside that directory, you can run several commands:')
    console.log()
    console.log(chalk.cyan(`  npm start`))
    console.log('    Starts the development server.')
    console.log()
    console.log(chalk.cyan(`  npm run build`))
    console.log('    Bundles the app into static files for production.')
    console.log()
    console.log(chalk.cyan(`  npm test`))
    console.log('    Starts the test runner.')
    console.log()
    console.log('We suggest that you begin by typing:')
    console.log()
    console.log(chalk.cyan('  cd'), path.relative(process.cwd(), appPath))
    console.log(`  ${chalk.cyan(`npm start`)}`)
    console.log()
    console.log('Happy hacking!')
  } catch (e) {
    exitWithError(chalk.red(e.message))
  }
}

function checkAppName(appName) {
  let validationResult = validateProjectName(appName)
  if (!validationResult.validForNewPackages) {
    console.error(
      `Could not create a project called ${chalk.red(
        `"${appName}"`
      )} because of npm naming restrictions:`
    )
    printValidationResults(validationResult.errors)
    printValidationResults(validationResult.warnings)

    exitWithError()
  }
}

function printValidationResults(results) {
  if (typeof results !== 'undefined') {
    results.forEach(error => {
      console.error(chalk.red(`  *  ${error}`))
    })
  }
}

// If project only contains files generated by GH, itâ€™s safe.
// Also, if project contains remnant error logs from a previous
// installation, lets remove them now.
// We also special case IJ-based products .idea because it integrates with CRA:
// https://github.com/facebook/create-react-app/pull/368#issuecomment-243446094
function isSafeToCreateProjectIn(root, name) {
  const validFiles = [
    '.DS_Store',
    'Thumbs.db',
    '.git',
    '.gitignore',
    '.idea',
    'README.md',
    'LICENSE',
    '.hg',
    '.hgignore',
    '.hgcheck',
    '.npmignore',
    'mkdocs.yml',
    'docs',
    '.travis.yml',
    '.gitlab-ci.yml',
    '.gitattributes'
  ]
  console.log()

  const conflicts = fs
    .readdirSync(root)
    .filter(file => !validFiles.includes(file))
    // IntelliJ IDEA creates module files before CRA is launched
    .filter(file => !/\.iml$/.test(file))
    // Don't treat log files from previous installation as conflicts
    .filter(file => !errorLogFilePatterns.some(pattern => file.indexOf(pattern) === 0))

  if (conflicts.length > 0) {
    console.error(`The directory ${chalk.green(name)} contains files that could conflict:`)
    console.error()
    conflicts.forEach(c => console.error(`  ${c}`))
    console.error()
    console.error('Either try using a new directory name, or remove the files listed above.')

    exitWithError()
  }

  // Remove any remnant files from a previous installation
  const currentFiles = fs.readdirSync(path.join(root))
  currentFiles.forEach(file => {
    errorLogFilePatterns.forEach(errorLogFilePattern => {
      // This will catch `(npm-debug|yarn-error|yarn-debug).log*` files
      if (file.indexOf(errorLogFilePattern) === 0) {
        fs.removeSync(path.join(root, file))
      }
    })
  })
}

// CommandName argument is only for debugging pursposes.
function promisifySpawn(child, commandName) {
  return new Promise((resolve, reject) => {
    child.on('close', code => {
      if (code !== 0) {
        reject(new Error(`${commandName} exited with code ${code}`))
        return
      }

      resolve()
    })
  })
}

function modifyDefaults(appName, appPath) {
  return new Promise(async (resolve, reject) => {
    const readPackageJson = path => JSON.parse(fs.readFileSync(path, 'utf-8'))

    let packageJsonPath = path.join(appPath, 'package.json')
    let packageJsonObject = readPackageJson(packageJsonPath)

    let promises = [
      packageJsonPath,
      path.join(appPath, '.travis.yml'),
      path.join(appPath, 'package-lock.json'),
      path.join(appPath, 'LICENSE'),
      path.join(appPath, 'README.md'),
      path.join(appPath, '.git')
    ].map(path => fs.remove(path))

    await Promise.all(promises)

    spawn.sync('git', ['init', appPath])

    // Init a new package in case user has set any npm config defaults.
    spawn.sync('npm', ['init', '-y'], { cwd: appPath })

    // The following properties should not be copied to new package.json
    delete packageJsonObject.name
    delete packageJsonObject.description
    delete packageJsonObject.keywords
    delete packageJsonObject.version
    delete packageJsonObject.author
    delete packageJsonObject.repository
    delete packageJsonObject.license

    let newPackageJsonObject = readPackageJson(packageJsonPath)

    // Main field defaults to incorrect jest.config.js, other fields are noise
    // when developing apps, which is the primary use of the boilerplate.
    delete newPackageJsonObject.main
    delete newPackageJsonObject.description
    delete newPackageJsonObject.keywords

    let mergedPackageJsonObject = Object.assign(newPackageJsonObject, packageJsonObject)
    let modifiedPackageJsonContents = JSON.stringify(mergedPackageJsonObject, null, 2) + os.EOL

    fs.writeFileSync(packageJsonPath, modifiedPackageJsonContents)

    resolve()
  })
}

function installPackages(appPath) {
  spawn.sync('npm', ['install', '--prefix', appPath], { stdio: 'inherit' })
}

function createInitialCommit(appPath) {
  spawn.sync('git', ['add', '-A'], { cwd: appPath })

  spawn.sync('git', ['commit', '-m', 'Initial commit'], { cwd: appPath })
}
